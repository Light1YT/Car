<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Yellow Car Game</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Commissioner:wght@400;700&display=swap');
    
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #222222;
      font-family: 'Commissioner', sans-serif;
    }
    canvas { 
      display: block; 
      background: transparent;
      box-shadow: 0 0 20px rgba(255, 238, 0, 0.3);
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
</head>
<body>

<script>
// Глобальная система управления звуком
class SoundManager {
  static isMuted = false;
  static musicVolume = 1.0;
  static effectsVolume = 1.0;
  static currentSounds = {}; // Отслеживание текущих звуков
  
  static init() {
    this.isMuted = GameData.load('soundMuted', false);
    this.musicVolume = GameData.load('musicVolume', 1.0);
    this.effectsVolume = GameData.load('effectsVolume', 1.0);
  }
  
  static toggleMute() {
    this.isMuted = !this.isMuted;
    GameData.save('soundMuted', this.isMuted);
  }
  
  static setMusicVolume(volume) {
    this.musicVolume = Math.max(0, Math.min(1, volume));
    GameData.save('musicVolume', this.musicVolume);
  }
  
  static setEffectsVolume(volume) {
    this.effectsVolume = Math.max(0, Math.min(1, volume));
    GameData.save('effectsVolume', this.effectsVolume);
  }
  
  static getMuteState() {
    this.init();
    return this.isMuted;
  }
  
  static playSound(scene, soundKey, baseVolume = 1) {
    if (!this.isMuted && scene.sound) {
      // Для звука benz не воспроизводим, если уже играет
      if (soundKey === 'benz' && this.currentSounds[soundKey] && this.currentSounds[soundKey].isPlaying) {
        return null; // Не воспроизводим новый звук
      }
      
      // Для других звуков останавливаем предыдущий звук того же типа если он играет
      if (soundKey !== 'benz' && this.currentSounds[soundKey] && this.currentSounds[soundKey].isPlaying) {
        this.currentSounds[soundKey].stop();
      }
      
      const finalVolume = baseVolume * this.effectsVolume;
      const sound = scene.sound.add(soundKey, { volume: finalVolume });
      
      // Сохраняем ссылку на звук
      this.currentSounds[soundKey] = sound;
      
      // Удаляем ссылку когда звук закончится
      sound.once('complete', () => {
        delete this.currentSounds[soundKey];
      });
      
      sound.play();
      return sound;
    }
    return null;
  }
  
  static playMusic(scene, musicKey, baseVolume = 1, loop = true) {
    if (!this.isMuted && scene.sound) {
      // Проверяем, не играет ли уже эта же музыка
      if (scene.currentMusic && scene.currentMusic.key === musicKey && scene.currentMusic.isPlaying) {
        // Обновляем громкость существующей музыки
        scene.currentMusic.setVolume(baseVolume * this.musicVolume);
        return scene.currentMusic;
      }
      
      // Останавливаем любую предыдущую музыку
      if (scene.currentMusic) {
        scene.currentMusic.stop();
      }
      
      // Запускаем новую музыку
      const finalVolume = baseVolume * this.musicVolume;
      scene.currentMusic = scene.sound.add(musicKey, { volume: finalVolume, loop: loop });
      scene.currentMusic.play();
      return scene.currentMusic;
    }
    return null;
  }
  
  static stopMusic(scene) {
    if (scene.currentMusic) {
      scene.currentMusic.stop();
      scene.currentMusic = null;
    }
  }
  
  static updateMuteState(scene) {
    if (this.isMuted) {
      if (scene.currentMusic) {
        scene.currentMusic.pause();
      }
    } else {
      if (scene.currentMusic && scene.currentMusic.isPaused) {
        scene.currentMusic.resume();
      }
    }
  }
  
  static updateMusicVolume(scene, baseVolume = 1) {
    if (scene.currentMusic && scene.currentMusic.isPlaying) {
      scene.currentMusic.setVolume(baseVolume * this.musicVolume);
    }
  }
}

// Система сохранения данных
class GameData {
  static save(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
  }
  
  static load(key, defaultValue = null) {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : defaultValue;
  }
  
  static addDiamonds(amount) {
    const current = this.load('diamonds', 0);
    this.save('diamonds', current + amount);
  }
  
  static getDiamonds() {
    return this.load('diamonds', 1000); // Тестовый баланс 1000 алмазов
  }
  
  static spendDiamonds(amount) {
    const current = this.getDiamonds();
    if (current >= amount) {
      this.save('diamonds', current - amount);
      return true;
    }
    return false;
  }
  
  static saveScore(score) {
    const scores = this.load('scores', []);
    scores.push(Math.floor(score));
    scores.sort((a, b) => b - a);
    scores.splice(10); // Оставляем только топ-10
    this.save('scores', scores);
  }
  
  static getTopScores() {
    return this.load('scores', []);
  }
  
  static canClaimDailyReward() {
    const lastClaim = this.load('lastDailyReward', 0);
    const now = Date.now();
    const oneDay = 24 * 60 * 60 * 1000; // 24 часа в миллисекундах
    return (now - lastClaim) >= oneDay;
  }
  
  static claimDailyReward() {
    if (this.canClaimDailyReward()) {
      this.addDiamonds(1);
      this.save('lastDailyReward', Date.now());
      return true;
    }
    return false;
  }
  
  static resetDiamonds() {
    // Принудительно устанавливаем тестовый баланс (для решения проблем с кешем)
    this.save('diamonds', 1000);
  }
  
  // Новые методы для управления локациями
  static getCurrentLocation() {
    return this.load('currentLocation', 'locSand'); // По умолчанию песчаная локация
  }
  
  static setCurrentLocation(location) {
    this.save('currentLocation', location);
  }
  
  static getNextLocation() {
    const current = this.getCurrentLocation();
    const locations = ['locSand', 'locbridge', 'loccity'];
    
    // Циклическая смена локаций для гарантированного попадания во все
    if (current === 'locSand') {
      return 'locbridge';
    } else if (current === 'locbridge') {
      return 'loccity';
    } else { // loccity
      return 'locSand';
    }
  }
  
  static advanceLocation() {
    const nextLocation = this.getNextLocation();
    this.setCurrentLocation(nextLocation);
    return nextLocation;
  }
}

// Главное меню
class MenuScene extends Phaser.Scene {
  constructor() {
    super('MenuScene');
  }

  preload() {
    // Загружаем фон меню и персонажей из папки Menu
    this.load.image('bgMenu', 'Menu/BG.png');
    this.load.image('man1', 'Menu/man1.png');
    this.load.image('man2', 'Menu/man2.png');
    
    // Загружаем спрайты монет для отображения в меню
    this.load.image('coin1', 'coin1.png');
    this.load.image('coin2', 'coin2.png');
    
    // Загружаем новые элементы интерфейса из папки Menu
    this.load.image('logo', 'Menu/Logo.png');
    this.load.image('playButton', 'Menu/Play.png');
    this.load.image('shopButton', 'Menu/Shop.png');
    this.load.image('actionsButton', 'Menu/Actions.png');
    this.load.image('lbButton', 'Menu/Lb.png');
    
    // Загружаем звуки
    this.load.audio('MM', 'MM.mp3');
    this.load.audio('GM', 'GM.mp3');
    this.load.audio('smash', 'smash.mp3');
    this.load.audio('coin', 'coin.mp3');
    this.load.audio('benz', 'benz.mp3');
  }

  create() {
    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;

    // Фон меню с эффектом блюра
    const bgMenu = this.add.image(gameWidth / 2, gameHeight / 2, 'bgMenu');
    bgMenu.setDisplaySize(gameWidth, gameHeight);
    bgMenu.setAlpha(0.85); // Делаем немного прозрачным для мягкого эффекта

    // Принудительно сбрасываем баланс для решения проблем с кешем
    GameData.resetDiamonds();

    // Инициализируем состояние звука
    SoundManager.getMuteState();
    
    // Запускаем фоновую музыку меню
    SoundManager.playMusic(this, 'MM', 0.008);
    
    // Кнопка управления звуком в правом верхнем углу
    this.createSoundButton(gameWidth * 0.9, gameHeight * 0.1);

    // Логотип компании
    const logo = this.add.image(gameWidth / 2, gameHeight * 0.15, 'logo');
    logo.setDisplaySize(gameWidth * 0.6, gameHeight * 0.12);

    // Новые кнопки меню (используем новые спрайты)
    // Кнопка "Играть"
    const playButton = this.add.image(gameWidth * 0.25, gameHeight * 0.42, 'playButton');
    playButton.setDisplaySize(gameWidth * 0.4, gameHeight * 0.08);
    playButton.setInteractive();
    
    playButton.on('pointerdown', () => {
      this.scene.start('MainScene');
    });
    


    // Кнопка "Магазин"
    const shopButton = this.add.image(gameWidth * 0.25, gameHeight * 0.54, 'shopButton');
    shopButton.setDisplaySize(gameWidth * 0.4, gameHeight * 0.08);
    shopButton.setInteractive();
    
    shopButton.on('pointerdown', () => {
      this.scene.start('ShopScene');
    });
    


    // Кнопка "Акции"
    const actionsButton = this.add.image(gameWidth * 0.25, gameHeight * 0.66, 'actionsButton');
    actionsButton.setDisplaySize(gameWidth * 0.4, gameHeight * 0.08);
    actionsButton.setInteractive();
    
    actionsButton.on('pointerdown', () => {
      this.scene.start('PromotionsScene');
    });
    


    // Кнопка "Таблица лидеров"
    const lbButton = this.add.image(gameWidth * 0.25, gameHeight * 0.78, 'lbButton');
    lbButton.setDisplaySize(gameWidth * 0.4, gameHeight * 0.1);
    lbButton.setInteractive();
    
    lbButton.on('pointerdown', () => {
      this.scene.start('LeaderboardScene');
    });
    


    // Добавляем персонажа в правую часть экрана (отзеркаленный, приподнятый)
    const character = this.add.image(gameWidth * 0.75, gameHeight * 0.7, 'man1');
    character.setDisplaySize(gameWidth * 0.45, gameHeight * 0.7);
    character.setFlipX(true); // Отзеркаливаем горизонтально
    
    // Анимация персонажа (переключение между man1 и man2)
    this.time.addEvent({
      delay: 2000,
      callback: () => {
        if (character.texture.key === 'man1') {
          character.setTexture('man2');
        } else {
          character.setTexture('man1');
        }
      },
      repeat: -1
    });
  }
  
  createSoundButton(x, y) {
    // Инициализируем состояние звука
    SoundManager.getMuteState();
    
    // Создаем кнопку звука
    const soundButton = this.add.text(x, y, SoundManager.isMuted ? '🔇' : '🔊', {
      font: 'bold 32px Arial',
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5).setInteractive();
    
    soundButton.on('pointerdown', () => {
      // Простое переключение звука без сложных overlay
      SoundManager.toggleMute();
      soundButton.setText(SoundManager.isMuted ? '🔇' : '🔊');
      SoundManager.updateMuteState(this);
      
      // Показываем уведомление
      this.showSoundNotification(x, y - 60);
    });
  }
  
  showSoundNotification(x, y) {
    // Создаем временное уведомление
    const notification = this.add.text(x, y, SoundManager.isMuted ? 'ЗВУК ВЫКЛЮЧЕН' : 'ЗВУК ВКЛЮЧЁН', {
      font: 'bold 16px Commissioner',
      fill: SoundManager.isMuted ? '#FF4444' : '#44FF44',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5);
    
    // Анимация появления и исчезновения
    this.tweens.add({
      targets: notification,
      alpha: 0,
      y: y - 30,
      duration: 2000,
      ease: 'Power2',
      onComplete: () => {
        notification.destroy();
      }
    });
  }
}

// Магазин
class ShopScene extends Phaser.Scene {
  constructor() {
    super('ShopScene');
  }

  preload() {
    // Загружаем изображения магазина из папки Shop
    this.load.image('shopName', 'Shop/shopName.png');
    this.load.image('s1', 'Shop/s1.png');
    this.load.image('s2', 'Shop/s2.png');
    this.load.image('s3', 'Shop/s3.png');
    this.load.image('s4', 'Shop/s4.png');
    this.load.image('b1', 'Shop/b1.png');
    
    // Загружаем фон меню для совместимости
    this.load.image('bgMenu', 'Menu/BG.png');
    // Загружаем спрайты монет
    this.load.image('coin1', 'coin1.png');
    this.load.image('coin2', 'coin2.png');
    
    // Загружаем звуки
    this.load.audio('MM', 'MM.mp3');
    this.load.audio('coin', 'coin.mp3');
  }

  create() {
    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;

    // Фон магазина
    const bgShop = this.add.image(gameWidth / 2, gameHeight / 2, 'bgMenu');
    bgShop.setDisplaySize(gameWidth, gameHeight);
    bgShop.setAlpha(0.7); // Делаем немного прозрачным для лучшей читаемости

    // Запускаем фоновую музыку меню
    SoundManager.playMusic(this, 'MM', 0.008);
    
    // Кнопка управления звуком в правом верхнем углу
    this.createSoundButton(gameWidth * 0.9, gameHeight * 0.1);

    // Заголовок магазина (используем shopName)
    const shopNameImage = this.add.image(gameWidth / 2, gameHeight * 0.08, 'shopName');
    shopNameImage.setDisplaySize(gameWidth * 0.6, gameHeight * 0.12);

    // Баланс
    const diamonds = GameData.getDiamonds();
    const balanceCoinIcon = this.add.image(gameWidth / 2 - 40, gameHeight * 0.15, 'coin1');
    balanceCoinIcon.setDisplaySize(gameWidth * 0.09, gameHeight * 0.06);
    this.diamondsText = this.add.text(gameWidth / 2 - 10, gameHeight * 0.15, `Баланс: ${diamonds}`, {
      font: 'bold 22px Commissioner',
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 1
    }).setOrigin(0, 0.5);

    // Товары (используем новые изображения кнопок)
    const items = [
      { name: 'Скидка 10%', price: 15, description: 'Скидка на все покупки', buttonImage: 's1' },
      { name: 'Скидка 15%', price: 25, description: 'Увеличенная скидка', buttonImage: 's2' },
      { name: 'Скидка 20%', price: 50, description: 'Максимальная скидка', buttonImage: 's3' },
      { name: 'Будильник', price: 15, description: 'Специальный предмет', buttonImage: 's4' }
    ];

    items.forEach((item, index) => {
      const y = gameHeight * 0.25 + index * (gameHeight * 0.1);
      this.createShopItem(gameWidth / 2, y, item);
    });

    // Кнопка назад (используем b1)
    const backButton = this.add.image(gameWidth * 0.15, gameHeight * 0.9, 'b1');
    backButton.setDisplaySize(gameWidth * 0.2, gameHeight * 0.08);
    backButton.setInteractive();
    
    backButton.on('pointerdown', () => {
      this.scene.start('MenuScene');
    });
  }

  createShopButton(x, y, text, callback) {
    // Создаем фон кнопки со скруглениями
    const buttonBg = this.add.graphics();
    buttonBg.fillStyle(0xFFEE00);
    buttonBg.fillRoundedRect(x - 40, y - 15, 80, 30, 12);
    buttonBg.lineStyle(2, 0x222222);
    buttonBg.strokeRoundedRect(x - 40, y - 15, 80, 30, 12);

    const button = this.add.text(x, y, text, {
      font: 'bold 12px Commissioner',
      fill: '#222222'
    })
      .setOrigin(0.5)
      .setInteractive()
      .on('pointerdown', callback)
      .on('pointerover', () => {
        buttonBg.clear();
        buttonBg.fillStyle(0x222222);
        buttonBg.fillRoundedRect(x - 40, y - 15, 80, 30, 12);
        buttonBg.lineStyle(2, 0xFFEE00);
        buttonBg.strokeRoundedRect(x - 40, y - 15, 80, 30, 12);
        button.setFill('#FFEE00');
      })
      .on('pointerout', () => {
        buttonBg.clear();
        buttonBg.fillStyle(0xFFEE00);
        buttonBg.fillRoundedRect(x - 40, y - 15, 80, 30, 12);
        buttonBg.lineStyle(2, 0x222222);
        buttonBg.strokeRoundedRect(x - 40, y - 15, 80, 30, 12);
        button.setFill('#222222');
      });
    return button;
  }

  createBackButton(x, y, text, callback) {
    // Создаем фон кнопки со скруглениями
    const buttonBg = this.add.graphics();
    buttonBg.fillStyle(0x222222);
    buttonBg.fillRoundedRect(x - 50, y - 20, 100, 40, 15);
    buttonBg.lineStyle(2, 0xC8C8C8);
    buttonBg.strokeRoundedRect(x - 50, y - 20, 100, 40, 15);

    const button = this.add.text(x, y, text, {
      font: 'bold 16px Commissioner',
      fill: '#C8C8C8'
    })
      .setOrigin(0.5)
      .setInteractive()
      .on('pointerdown', callback)
      .on('pointerover', () => {
        buttonBg.clear();
        buttonBg.fillStyle(0xC8C8C8);
        buttonBg.fillRoundedRect(x - 50, y - 20, 100, 40, 15);
        buttonBg.lineStyle(2, 0x222222);
        buttonBg.strokeRoundedRect(x - 50, y - 20, 100, 40, 15);
        button.setFill('#222222');
      })
      .on('pointerout', () => {
        buttonBg.clear();
        buttonBg.fillStyle(0x222222);
        buttonBg.fillRoundedRect(x - 50, y - 20, 100, 40, 15);
        buttonBg.lineStyle(2, 0xC8C8C8);
        buttonBg.strokeRoundedRect(x - 50, y - 20, 100, 40, 15);
        button.setFill('#C8C8C8');
      });
    return button;
  }

  createShopItem(x, y, item) {
    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;
    
    // Используем изображение кнопки товара
    const itemButton = this.add.image(x, y, item.buttonImage);
    itemButton.setDisplaySize(gameWidth * 0.8, gameHeight * 0.08);
    itemButton.setInteractive();
    
    itemButton.on('pointerdown', () => {
      this.buyItem(item);
    });
  }

  buyItem(item) {
    // Проверяем, является ли товар скидкой
    if (item.name.includes('Скидка')) {
      this.showDiscountWarning(item);
    } else {
      if (GameData.spendDiamonds(item.price)) {
        // Воспроизводим звук покупки (монетка)
        SoundManager.playSound(this, 'coin', 1.8);
        this.showPurchaseConfirmation(item);
        this.updateDiamondsDisplay();
      } else {
        this.showMessage('Недостаточно монет!');
      }
    }
  }

  showDiscountWarning(item) {
    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;

    // Затемнение
    const overlay = this.add.rectangle(gameWidth / 2, gameHeight / 2, gameWidth, gameHeight, 0x000000, 0.7);

    // Окно предупреждения (увеличено по высоте для двух рядов кнопок)
    const warningBox = this.add.rectangle(gameWidth / 2, gameHeight / 2, gameWidth * 0.85, gameHeight * 0.6, 0x333333);
    warningBox.setStrokeStyle(3, 0xFFFF00);

    const titleText = this.add.text(gameWidth / 2, gameHeight / 2 - gameHeight * 0.2, 'ВНИМАНИЕ!', {
      font: 'bold 24px Arial',
      fill: '#FFFF00',
      stroke: '#000',
      strokeThickness: 2
    }).setOrigin(0.5);

    const warningText = this.add.text(gameWidth / 2, gameHeight / 2 - gameHeight * 0.08, 
      'После покупки вы направляетесь\nна уникальную форму записи.\n\nТОЛЬКО ПО НЕЙ ВЫ СМОЖЕТЕ\nПОЛУЧИТЬ СКИДКУ!', {
      font: 'bold 16px Arial',
      fill: '#fff',
      stroke: '#000',
      strokeThickness: 1,
      align: 'center'
    }).setOrigin(0.5);

    const continueButton = this.createButton(gameWidth / 2, gameHeight / 2 + gameHeight * 0.08, 'ПРОДОЛЖИТЬ', {
      font: 'bold 16px Arial',
      fill: '#fff',
      backgroundColor: '#00aa00',
      stroke: '#000',
      strokeThickness: 2
    }, () => {
      if (GameData.spendDiamonds(item.price)) {
        this.destroyWarningDialog(overlay, warningBox, titleText, warningText, continueButton, cancelButton);
        this.showPurchaseConfirmation(item);
        this.updateDiamondsDisplay();
      } else {
        this.destroyWarningDialog(overlay, warningBox, titleText, warningText, continueButton, cancelButton);
        this.showMessage('Недостаточно монет!');
      }
    });

    const cancelButton = this.createButton(gameWidth / 2, gameHeight / 2 + gameHeight * 0.16, 'ОТМЕНА', {
      font: 'bold 16px Arial',
      fill: '#fff',
      backgroundColor: '#aa0000',
      stroke: '#000',
      strokeThickness: 2
    }, () => {
      this.destroyWarningDialog(overlay, warningBox, titleText, warningText, continueButton, cancelButton);
    });
  }

  destroyWarningDialog(overlay, warningBox, titleText, warningText, continueButton, cancelButton) {
    overlay.destroy();
    warningBox.destroy();
    titleText.destroy();
    warningText.destroy();
    continueButton.destroy();
    cancelButton.destroy();
  }

  showPurchaseConfirmation(item) {
    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;

    // Затемнение
    const overlay = this.add.rectangle(gameWidth / 2, gameHeight / 2, gameWidth, gameHeight, 0x000000, 0.7);

    // Окно подтверждения (увеличено по высоте для двух рядов кнопок)
    const confirmBox = this.add.rectangle(gameWidth / 2, gameHeight / 2, 400, 320, 0x333333);
    confirmBox.setStrokeStyle(3, 0xFFFFFF);

    const titleText = this.add.text(gameWidth / 2, gameHeight / 2 - 60, 'ПОКУПКА СОВЕРШЕНА!', {
      font: 'bold 24px Arial',
      fill: '#00ff00',
      stroke: '#000',
      strokeThickness: 2
    }).setOrigin(0.5);

    const itemText = this.add.text(gameWidth / 2, gameHeight / 2 - 20, `${item.name} приобретен!`, {
      font: '18px Arial',
      fill: '#fff'
    }).setOrigin(0.5);

    const questionText = this.add.text(gameWidth / 2, gameHeight / 2 + 10, 'Перейти на сайт?', {
      font: '16px Arial',
      fill: '#ccc'
    }).setOrigin(0.5);

    const yesButton = this.createButton(gameWidth / 2, gameHeight / 2 + 40, 'ДА', {
      font: 'bold 20px Arial',
      fill: '#fff',
      backgroundColor: '#00aa00',
      stroke: '#000',
      strokeThickness: 2
    }, () => {
      this.openLink('https://koreanaparts.ru/block/119');
      this.destroyConfirmDialog(overlay, confirmBox, titleText, itemText, questionText, yesButton, noButton);
    });

    const noButton = this.createButton(gameWidth / 2, gameHeight / 2 + 100, 'НЕТ', {
      font: 'bold 20px Arial',
      fill: '#fff',
      backgroundColor: '#aa0000',
      stroke: '#000',
      strokeThickness: 2
    }, () => {
      this.destroyConfirmDialog(overlay, confirmBox, titleText, itemText, questionText, yesButton, noButton);
    });
  }

  destroyConfirmDialog(overlay, confirmBox, titleText, itemText, questionText, yesButton, noButton) {
    overlay.destroy();
    confirmBox.destroy();
    titleText.destroy();
    itemText.destroy();
    questionText.destroy();
    yesButton.destroy();
    noButton.destroy();
  }

  openLink(url) {
    // Для мобильных устройств используем location.href
    if (this.sys.game.device.os.iOS || this.sys.game.device.os.android) {
      location.href = url;
    } else {
      window.open(url, '_blank');
    }
  }

  showMessage(text) {
    const gameHeight = this.sys.game.config.height;
    
    // Создаем фон уведомления
    const messageBg = this.add.graphics();
    messageBg.fillStyle(0x222222, 0.9);
    messageBg.fillRoundedRect(this.sys.game.config.width / 2 - 150, gameHeight * 0.85 - 25, 300, 50, 15);
    messageBg.lineStyle(2, 0xFFEE00);
    messageBg.strokeRoundedRect(this.sys.game.config.width / 2 - 150, gameHeight * 0.85 - 25, 300, 50, 15);
    
    const message = this.add.text(this.sys.game.config.width / 2, gameHeight * 0.85, text, {
      font: 'bold 16px Commissioner',
      fill: '#FFEE00',
      align: 'center'
    }).setOrigin(0.5);

    this.time.delayedCall(2000, () => {
      message.destroy();
      messageBg.destroy();
    });
  }

  updateDiamondsDisplay() {
    const diamonds = GameData.getDiamonds();
    this.diamondsText.setText(`Баланс: ${diamonds}`);
    this.diamondsText.setStyle({
      font: 'bold 22px Commissioner',
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 1
    });
  }

  createButton(x, y, text, style, callback) {
    const button = this.add.text(x, y, text, style)
      .setOrigin(0.5)
      .setPadding(15, 10)
      .setInteractive()
      .on('pointerdown', callback);
    return button;
  }

  createSoundButton(x, y) {
    // Инициализируем состояние звука
    SoundManager.getMuteState();
    
    // Создаем кнопку звука
    const soundButton = this.add.text(x, y, SoundManager.isMuted ? '🔇' : '🔊', {
      font: 'bold 32px Arial',
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5).setInteractive();
    
    soundButton.on('pointerdown', () => {
      // Простое переключение звука без сложных overlay
      SoundManager.toggleMute();
      soundButton.setText(SoundManager.isMuted ? '🔇' : '🔊');
      SoundManager.updateMuteState(this);
      
      // Показываем уведомление
      this.showSoundNotification(x, y - 60);
    });
  }
  
  showSoundNotification(x, y) {
    // Создаем временное уведомление
    const notification = this.add.text(x, y, SoundManager.isMuted ? 'ЗВУК ВЫКЛЮЧЕН' : 'ЗВУК ВКЛЮЧЁН', {
      font: 'bold 16px Commissioner',
      fill: SoundManager.isMuted ? '#FF4444' : '#44FF44',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5);
    
    // Анимация появления и исчезновения
    this.tweens.add({
      targets: notification,
      alpha: 0,
      y: y - 30,
      duration: 2000,
      ease: 'Power2',
      onComplete: () => {
        notification.destroy();
      }
    });
  }
}

// Акции
class PromotionsScene extends Phaser.Scene {
  constructor() {
    super('PromotionsScene');
  }

  preload() {
    // Загружаем изображения акций из папки Actions
    this.load.image('actionName', 'Actions/actionName.png');
    this.load.image('daily', 'Actions/daily.png');
    this.load.image('dbl', 'Actions/dbl.png');
    this.load.image('mem', 'Actions/mem.png');
    this.load.image('special', 'Actions/special.png');
    this.load.image('b2', 'Actions/b2.png');
    
    // Загружаем фон меню для совместимости
    this.load.image('bgMenu', 'Menu/BG.png');
    
    // Загружаем звуки
    this.load.audio('MM', 'MM.mp3');
    this.load.audio('coin', 'coin.mp3');
  }

  create() {
    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;

    // Фон акций
    const bgPromo = this.add.image(gameWidth / 2, gameHeight / 2, 'bgMenu');
    bgPromo.setDisplaySize(gameWidth, gameHeight);
    bgPromo.setAlpha(0.6); // Делаем немного прозрачным для лучшей читаемости

    // Запускаем фоновую музыку меню
    SoundManager.playMusic(this, 'MM', 0.008);
    
    // Кнопка управления звуком в правом верхнем углу
    this.createSoundButton(gameWidth * 0.9, gameHeight * 0.1);

    // Заголовок акций (используем actionName)
    const actionNameImage = this.add.image(gameWidth / 2, gameHeight * 0.08, 'actionName');
    actionNameImage.setDisplaySize(gameWidth * 0.6, gameHeight * 0.12);

    // Ежедневная награда (используем daily)
    const dailyButton = this.add.image(gameWidth / 2, gameHeight * 0.25, 'daily');
    dailyButton.setDisplaySize(gameWidth * 0.8, gameHeight * 0.08);
    dailyButton.setInteractive();
    this.createDailyRewardButton(dailyButton);
    
    // Двойная награда в выходные (используем dbl)
    const dblButton = this.add.image(gameWidth / 2, gameHeight * 0.38, 'dbl');
    dblButton.setDisplaySize(gameWidth * 0.8, gameHeight * 0.08);
    dblButton.setInteractive();
    
    // Мем за алмаз (используем mem)
    const memButton = this.add.image(gameWidth / 2, gameHeight * 0.51, 'mem');
    memButton.setDisplaySize(gameWidth * 0.8, gameHeight * 0.08);
    memButton.setInteractive();
    
    memButton.on('pointerdown', () => {
      this.openLink('https://www.anekdot.ru/last/mem/');
    });
    
    // Специальные предложения (используем special)
    const specialButton = this.add.image(gameWidth / 2, gameHeight * 0.64, 'special');
    specialButton.setDisplaySize(gameWidth * 0.8, gameHeight * 0.08);
    specialButton.setInteractive();
    
    specialButton.on('pointerdown', () => {
      this.openLink('https://koreanaparts.ru/specpredlozheniya-i-akcii-kompanii-koreana-sankt-peterburg');
    });

    // Кнопка назад (используем b2)
    const backButton = this.add.image(gameWidth * 0.15, gameHeight * 0.82, 'b2');
    backButton.setDisplaySize(gameWidth * 0.2, gameHeight * 0.08);
    backButton.setInteractive();
    
    backButton.on('pointerdown', () => {
      this.scene.start('MenuScene');
    });
  }

  createBackButton(x, y, text, callback) {
    // Создаем фон кнопки со скруглениями
    const buttonBg = this.add.graphics();
    buttonBg.fillStyle(0x222222);
    buttonBg.fillRoundedRect(x - 50, y - 20, 100, 40, 15);
    buttonBg.lineStyle(2, 0xC8C8C8);
    buttonBg.strokeRoundedRect(x - 50, y - 20, 100, 40, 15);

    const button = this.add.text(x, y, text, {
      font: 'bold 16px Commissioner',
      fill: '#C8C8C8'
    })
      .setOrigin(0.5)
      .setInteractive()
      .on('pointerdown', callback)
      .on('pointerover', () => {
        buttonBg.clear();
        buttonBg.fillStyle(0xC8C8C8);
        buttonBg.fillRoundedRect(x - 50, y - 20, 100, 40, 15);
        buttonBg.lineStyle(2, 0x222222);
        buttonBg.strokeRoundedRect(x - 50, y - 20, 100, 40, 15);
        button.setFill('#222222');
      })
      .on('pointerout', () => {
        buttonBg.clear();
        buttonBg.fillStyle(0x222222);
        buttonBg.fillRoundedRect(x - 50, y - 20, 100, 40, 15);
        buttonBg.lineStyle(2, 0xC8C8C8);
        buttonBg.strokeRoundedRect(x - 50, y - 20, 100, 40, 15);
        button.setFill('#C8C8C8');
      });
    return button;
  }

  createDailyRewardButton(button) {
    const canClaim = GameData.canClaimDailyReward();
    
    if (canClaim) {
      button.setAlpha(1.0); // Полная яркость если доступно
      button.on('pointerdown', () => {
        if (GameData.claimDailyReward()) {
          SoundManager.playSound(this, 'coin', 1.8);
          this.showMessage('Получена 1 монета! Возвращайтесь завтра!');
          button.setAlpha(0.5); // Делаем тусклой
          button.removeInteractive();
        }
      });
      

    } else {
      button.setAlpha(0.5); // Тусклая если недоступно
    }
  }

  createPromotion(x, y, text, callback) {
    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;
    
    const promoBg = this.add.graphics();
    const bgColor = callback ? 0x222222 : 0xC8C8C8;
    const strokeColor = callback ? 0xFFEE00 : 0x222222;
    promoBg.fillStyle(bgColor, 0.2);
    promoBg.fillRoundedRect(x - gameWidth * 0.38, y - gameHeight * 0.03, gameWidth * 0.76, gameHeight * 0.06, 12);
    promoBg.lineStyle(2, strokeColor);
    promoBg.strokeRoundedRect(x - gameWidth * 0.38, y - gameHeight * 0.03, gameWidth * 0.76, gameHeight * 0.06, 12);

    const promoText = this.add.text(x, y, text, {
      font: 'bold 14px Commissioner',
      fill: callback ? '#FFEE00' : '#222222'
    }).setOrigin(0.5);

    if (callback) {
      promoText.setInteractive()
        .on('pointerdown', callback)
        .on('pointerover', () => {
          // Эффект наведения - инвертируем цвета
          promoBg.clear();
          promoBg.fillStyle(0xFFEE00, 0.2);
          promoBg.fillRoundedRect(x - gameWidth * 0.38, y - gameHeight * 0.03, gameWidth * 0.76, gameHeight * 0.06, 12);
          promoBg.lineStyle(2, 0x222222);
          promoBg.strokeRoundedRect(x - gameWidth * 0.38, y - gameHeight * 0.03, gameWidth * 0.76, gameHeight * 0.06, 12);
          promoText.setFill('#222222');
        })
        .on('pointerout', () => {
          // Возвращаем обычные цвета
          promoBg.clear();
          promoBg.fillStyle(0x222222, 0.2);
          promoBg.fillRoundedRect(x - gameWidth * 0.38, y - gameHeight * 0.03, gameWidth * 0.76, gameHeight * 0.06, 12);
          promoBg.lineStyle(2, 0xFFEE00);
          promoBg.strokeRoundedRect(x - gameWidth * 0.38, y - gameHeight * 0.03, gameWidth * 0.76, gameHeight * 0.06, 12);
          promoText.setFill('#FFEE00');
        });
    }
  }

  showMessage(text) {
    const gameHeight = this.sys.game.config.height;
    
    // Создаем фон уведомления
    const messageBg = this.add.graphics();
    messageBg.fillStyle(0x222222, 0.9);
    messageBg.fillRoundedRect(this.sys.game.config.width / 2 - 150, gameHeight * 0.85 - 25, 300, 50, 15);
    messageBg.lineStyle(2, 0xFFEE00);
    messageBg.strokeRoundedRect(this.sys.game.config.width / 2 - 150, gameHeight * 0.85 - 25, 300, 50, 15);
    
    const message = this.add.text(this.sys.game.config.width / 2, gameHeight * 0.85, text, {
      font: 'bold 16px Commissioner',
      fill: '#FFEE00',
      align: 'center'
    }).setOrigin(0.5);

    this.time.delayedCall(3000, () => {
      message.destroy();
      messageBg.destroy();
    });
  }

  openLink(url) {
    // Для мобильных устройств используем location.href
    if (this.sys.game.device.os.iOS || this.sys.game.device.os.android) {
      location.href = url;
    } else {
      window.open(url, '_blank');
    }
  }

  createButton(x, y, text, style, callback) {
    const button = this.add.text(x, y, text, style)
      .setOrigin(0.5)
      .setPadding(15, 10)
      .setInteractive()
      .on('pointerdown', callback);
    return button;
  }

  createSoundButton(x, y) {
    // Инициализируем состояние звука
    SoundManager.getMuteState();
    
    // Создаем кнопку звука
    const soundButton = this.add.text(x, y, SoundManager.isMuted ? '🔇' : '🔊', {
      font: 'bold 32px Arial',
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5).setInteractive();
    
    soundButton.on('pointerdown', () => {
      // Простое переключение звука без сложных overlay
      SoundManager.toggleMute();
      soundButton.setText(SoundManager.isMuted ? '🔇' : '🔊');
      SoundManager.updateMuteState(this);
      
      // Показываем уведомление
      this.showSoundNotification(x, y - 60);
    });
  }
  
  showSoundNotification(x, y) {
    // Создаем временное уведомление
    const notification = this.add.text(x, y, SoundManager.isMuted ? 'ЗВУК ВЫКЛЮЧЕН' : 'ЗВУК ВКЛЮЧЁН', {
      font: 'bold 16px Commissioner',
      fill: SoundManager.isMuted ? '#FF4444' : '#44FF44',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5);
    
    // Анимация появления и исчезновения
    this.tweens.add({
      targets: notification,
      alpha: 0,
      y: y - 30,
      duration: 2000,
      ease: 'Power2',
      onComplete: () => {
        notification.destroy();
      }
    });
  }
}

// Таблица лидеров
class LeaderboardScene extends Phaser.Scene {
  constructor() {
    super('LeaderboardScene');
  }

  preload() {
    // Загружаем фон меню для совместимости
    this.load.image('bgMenu', 'Menu/BG.png');
    
    // Загружаем звуки
    this.load.audio('MM', 'MM.mp3');
  }

  create() {
    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;

    // Фон таблицы лидеров
    const bgLeader = this.add.image(gameWidth / 2, gameHeight / 2, 'bgMenu');
    bgLeader.setDisplaySize(gameWidth, gameHeight);
    bgLeader.setAlpha(0.6); // Делаем немного прозрачным для лучшей читаемости

    // Запускаем фоновую музыку меню
    SoundManager.playMusic(this, 'MM', 0.008);
    
    // Кнопка управления звуком в правом верхнем углу
    this.createSoundButton(gameWidth * 0.9, gameHeight * 0.1);

    // Заголовок
    this.add.text(gameWidth / 2, gameHeight * 0.08, 'ТАБЛИЦА ЛИДЕРОВ', {
      font: 'bold 28px Commissioner',
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5);

    // Получаем рекорды
    const scores = GameData.getTopScores();

    if (scores.length === 0) {
      this.add.text(gameWidth / 2, gameHeight * 0.4, 'Пока нет рекордов', {
        font: 'bold 20px Commissioner',
        fill: '#C8C8C8'
      }).setOrigin(0.5);
    } else {
      scores.forEach((score, index) => {
        const y = gameHeight * 0.22 + index * (gameHeight * 0.045);
        const medal = index < 3 ? ['🥇', '🥈', '🥉'][index] : `${index + 1}.`;
        
        this.add.text(gameWidth / 2, y, `${medal} ${score} очков`, {
          font: 'bold 16px Commissioner',
          fill: '#FFEE00',
          stroke: '#222222',
          strokeThickness: 1
        }).setOrigin(0.5);
      });
    }

    // Кнопка назад
    this.createBackButton(gameWidth * 0.15, gameHeight * 0.9, 'НАЗАД', () => {
      this.scene.start('MenuScene');
    });
  }

  createBackButton(x, y, text, callback) {
    // Создаем фон кнопки со скруглениями
    const buttonBg = this.add.graphics();
    buttonBg.fillStyle(0x222222);
    buttonBg.fillRoundedRect(x - 50, y - 20, 100, 40, 15);
    buttonBg.lineStyle(2, 0xC8C8C8);
    buttonBg.strokeRoundedRect(x - 50, y - 20, 100, 40, 15);

    const button = this.add.text(x, y, text, {
      font: 'bold 16px Commissioner',
      fill: '#C8C8C8'
    })
      .setOrigin(0.5)
      .setInteractive()
      .on('pointerdown', callback)
      .on('pointerover', () => {
        buttonBg.clear();
        buttonBg.fillStyle(0xC8C8C8);
        buttonBg.fillRoundedRect(x - 50, y - 20, 100, 40, 15);
        buttonBg.lineStyle(2, 0x222222);
        buttonBg.strokeRoundedRect(x - 50, y - 20, 100, 40, 15);
        button.setFill('#222222');
      })
      .on('pointerout', () => {
        buttonBg.clear();
        buttonBg.fillStyle(0x222222);
        buttonBg.fillRoundedRect(x - 50, y - 20, 100, 40, 15);
        buttonBg.lineStyle(2, 0xC8C8C8);
        buttonBg.strokeRoundedRect(x - 50, y - 20, 100, 40, 15);
        button.setFill('#C8C8C8');
      });
    return button;
  }

  createButton(x, y, text, style, callback) {
    const button = this.add.text(x, y, text, style)
      .setOrigin(0.5)
      .setPadding(15, 10)
      .setInteractive()
      .on('pointerdown', callback)
      .on('pointerover', () => {
        button.setScale(1.1);
      })
      .on('pointerout', () => {
        button.setScale(1);
      });
    return button;
  }

  createSoundButton(x, y) {
    // Инициализируем состояние звука
    SoundManager.getMuteState();
    
    // Создаем кнопку звука
    const soundButton = this.add.text(x, y, SoundManager.isMuted ? '🔇' : '🔊', {
      font: 'bold 32px Arial',
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5).setInteractive();
    
    soundButton.on('pointerdown', () => {
      // Простое переключение звука без сложных overlay
      SoundManager.toggleMute();
      soundButton.setText(SoundManager.isMuted ? '🔇' : '🔊');
      SoundManager.updateMuteState(this);
      
      // Показываем уведомление
      this.showSoundNotification(x, y - 60);
    });
    
    soundButton.on('pointerover', () => {
      soundButton.setScale(1.05);
    });
    
    soundButton.on('pointerout', () => {
      soundButton.setScale(1);
    });
  }
  
  showSoundNotification(x, y) {
    // Создаем временное уведомление
    const notification = this.add.text(x, y, SoundManager.isMuted ? 'ЗВУК ВЫКЛЮЧЕН' : 'ЗВУК ВКЛЮЧЁН', {
      font: 'bold 16px Commissioner',
      fill: SoundManager.isMuted ? '#FF4444' : '#44FF44',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5);
    
    // Анимация появления и исчезновения
    this.tweens.add({
      targets: notification,
      alpha: 0,
      y: y - 30,
      duration: 2000,
      ease: 'Power2',
      onComplete: () => {
        notification.destroy();
      }
    });
  }
}

// Основная игра (модифицированная с поддержкой локаций)
class MainScene extends Phaser.Scene {
  constructor() {
    super('MainScene');
    this.gameOverFlag = false;
    this.touchStartX = 0;
    this.touchStartY = 0;
    this.isTouching = false;
    this.currentLocation = 'locSand'; // Текущая локация
    this.lastLocationChangeTime = 0; // Время последней смены локации
  }

  preload() {
    // Машинки игрока
    this.load.image('car', 'car.png');
    this.load.image('carL', 'carL.png');
    this.load.image('carR', 'carR.png');
    
    // Локация locSand (песчаная пустыня)
    this.load.image('bgsand', 'locSand/bgsand.png');
    this.load.image('sandCar4', 'locSand/car4.png');
    this.load.image('sandCar5', 'locSand/car5.png');
    this.load.image('sandCar6', 'locSand/car6.png');
    
    // Локация locbridge (мост)
    this.load.image('bridge', 'locbridge/bridge.png');
    this.load.image('bridgeEc', 'locbridge/ec.png');
    this.load.image('bridgeEc1', 'locbridge/ec1.png');
    this.load.image('bridgeEc2', 'locbridge/ec2.png');
    this.load.image('bridgeCar4', 'locbridge/car4.png');
    this.load.image('bridgeCar5', 'locbridge/car5.png');
    this.load.image('bridgeCar6', 'locbridge/car6.png');
    
    // Локация loccity (город)
    this.load.image('city', 'loccity/city.png');
    this.load.image('cityEc', 'loccity/ec.png');
    this.load.image('cityEc1', 'loccity/ec1.png');
    this.load.image('cityEc2', 'loccity/ec2.png');
    
    // Бонусы и монеты
    this.load.image('bonus1', 'bonus1.png');
    this.load.image('bonus2', 'bonus2.png');
    this.load.image('coin1', 'coin1.png');
    this.load.image('coin2', 'coin2.png');
    
    // Фон меню
    this.load.image('bgMenu', 'Menu/BG.png');
    
    // Загружаем все звуки
    this.load.audio('GM', 'GM.mp3');
    this.load.audio('smash', 'smash.mp3');
    this.load.audio('coin', 'coin.mp3');
    this.load.audio('benz', 'benz.mp3');
  }

  create() {
    this.laneCount = 3;
    this.speed = 200;
    this.score = 0;
    this.nextSpeedUp = 0;
    this.lastObstacleSpawnTime = 0;
    this.lastDiamondSpawnTime = 0;
    this.gameOverFlag = false;

    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;
    this.laneWidth = gameWidth / this.laneCount;
    
    // Инициализируем текущую локацию
    this.currentLocation = GameData.getCurrentLocation();

    // Создаем дорогу и фоновые элементы
    this.createRoad();
    this.createBackgroundElements();

    // Создаем игрока в центральной полосе дороги
    const playerX = this.roadStart + 1 * this.laneWidth + this.laneWidth / 2; // Центральная полоса (lane 1)
    this.player = this.physics.add.sprite(playerX, gameHeight * 0.8, 'car');
    this.player.setDisplaySize(gameWidth * 0.15, gameHeight * 0.08);
    this.player.setCollideWorldBounds(true);
    this.player.lane = 1;
    this.player.currentDirection = 'center'; // Отслеживаем текущее направление

    this.obstacles = this.physics.add.group();
    this.bonuses = this.physics.add.group();
    this.extraBonuses = this.physics.add.group(); // Новая группа для монет

    this.physics.add.overlap(this.player, this.obstacles, () => this.handleGameOver(), null, this);
    this.physics.add.overlap(this.player, this.bonuses, (player, bonus) => {
      bonus.destroy();
      this.score += 50;
      // Воспроизводим звук сбора бензина
      SoundManager.playSound(this, 'benz', 1.0);
      this.createScoreEffect(bonus.x, bonus.y, '+50');
    }, null, this);

    // Обработка сбора монеток (экстра бонусов)
    this.physics.add.overlap(this.player, this.extraBonuses, (player, coin) => {
      coin.destroy();
      GameData.addDiamonds(1);
      // Воспроизводим звук сбора монетки
      SoundManager.playSound(this, 'coin', 1.8);
      this.createScoreEffect(coin.x, coin.y, '+1');
      this.updateDiamondsDisplay();
    }, null, this);

    // Улучшенный счет
    this.scoreText = this.add.text(20, 20, 'СЧЕТ: 0', { 
      font: 'bold 24px Commissioner', 
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 2
    });

    // Отображение монет в игре
    const gameCoinIcon = this.add.image(20, 75, 'coin1');
    gameCoinIcon.setDisplaySize(gameWidth * 0.12, gameHeight * 0.07);
    gameCoinIcon.setOrigin(0, 0.5);
    this.diamondsText = this.add.text(70, 60, `${GameData.getDiamonds()}`, {
      font: 'bold 20px Commissioner',
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 1
    });

    this.input.keyboard.on('keydown-LEFT', () => this.changeLane(-1));
    this.input.keyboard.on('keydown-RIGHT', () => this.changeLane(1));
    
    // Управление свайпами
    this.input.on('pointerdown', (pointer) => {
      this.touchStartX = pointer.x;
      this.touchStartY = pointer.y;
      this.isTouching = true;
    });
    
    this.input.on('pointerup', (pointer) => {
      if (this.isTouching) {
        this.handleSwipe(pointer.x, pointer.y);
        this.isTouching = false;
      }
    });
    
    this.input.on('pointermove', (pointer) => {
      if (this.isTouching) {
        const deltaX = pointer.x - this.touchStartX;
        const deltaY = pointer.y - this.touchStartY;
        
        if (Math.abs(deltaX) > 50 && Math.abs(deltaX) > Math.abs(deltaY)) {
          if (deltaX > 0) {
            this.changeLane(1);
          } else {
            this.changeLane(-1);
          }
          this.isTouching = false;
        }
      }
    });

    // Принудительно останавливаем всю предыдущую музыку
    if (this.sound && this.sound.sounds) {
      this.sound.sounds.forEach(sound => {
        if (sound.isPlaying) {
          sound.stop();
        }
      });
    }
    
    // Запускаем игровую музыку
    SoundManager.playMusic(this, 'GM', 0.175);
    
    // Кнопка управления звуком в правом верхнем углу
    this.createSoundButton(gameWidth * 0.9, gameHeight * 0.1);
  }

  createRoad() {
    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;
    
    // Создаем группы для анимированных элементов дороги
    this.roadElements = this.add.group();
    
    // Определяем изображение для текущей локации
    let roadImage;
    switch (this.currentLocation) {
      case 'locSand':
        roadImage = 'bgsand';
        break;
      case 'locbridge':
        roadImage = 'bridge';
        break;
      case 'loccity':
        roadImage = 'city';
        break;
      default:
        roadImage = 'bgsand';
    }
    
    // Создаем несколько копий дороги для бесконечной прокрутки
    for (let i = 0; i < 3; i++) {
      const yOffset = i * gameHeight - gameHeight;
      
      // Дорога с окружением (полная ширина экрана)
      const road = this.add.image(gameWidth / 2, gameHeight / 2 + yOffset, roadImage);
      road.setDisplaySize(gameWidth, gameHeight);
      this.roadElements.add(road);
    }
    
    // Настройка параметров для игровой логики (3 полосы только в пределах дорожного полотна)
    // Дорога занимает центральную часть экрана - примерно 55% ширины
    const roadWidth = gameWidth * 0.55;
    const roadStart = gameWidth * 0.225; // Центрируем дорогу
    const laneWidth = roadWidth / this.laneCount;
    
    this.laneWidth = laneWidth;
    this.roadStart = roadStart;
  }

  createBackgroundElements() {
    // Удаляем старые фоновые элементы, так как теперь используем спрайты дороги
    // Новые спрайты roadL, roadM, roadR уже содержат все необходимые элементы окружения
  }

  createScoreEffect(x, y, text) {
    if (text === '+1') {
      // Для монет создаем иконку вместо текста
      const coinEffect = this.add.image(x, y, 'coin1');
      coinEffect.setDisplaySize(this.sys.game.config.width * 0.06, this.sys.game.config.height * 0.04);
      
      this.tweens.add({
        targets: coinEffect,
        y: y - 50,
        alpha: 0,
        duration: 1000,
        ease: 'Power2',
        onComplete: () => coinEffect.destroy()
      });
    } else {
      const scoreText = this.add.text(x, y, text, {
        font: 'bold 20px Arial',
        fill: '#00ff00',
        stroke: '#000',
        strokeThickness: 2
      }).setOrigin(0.5);
      
      this.tweens.add({
        targets: scoreText,
        y: y - 50,
        alpha: 0,
        duration: 1000,
        ease: 'Power2',
        onComplete: () => scoreText.destroy()
      });
    }
  }

  updateDiamondsDisplay() {
    this.diamondsText.setText(`${GameData.getDiamonds()}`);
    this.diamondsText.setStyle({
      font: 'bold 20px Commissioner',
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 1
    });
  }

  update(time, delta) {
    if (this.gameOverFlag) return;

    if (time > this.nextSpeedUp) {
      this.speed += 25;
      this.nextSpeedUp = time + 5000;
    }

    this.score += delta * 0.01;
    this.scoreText.setText('СЧЕТ: ' + Math.floor(this.score));
    
    // Проверяем смену локации каждые 10 секунд для тестирования
    if (time - this.lastLocationChangeTime > 10000) {
      this.changeLocation();
      this.lastLocationChangeTime = time;
    }

    // Спавн монеток каждые 25 секунд
    if (time - this.lastDiamondSpawnTime > 25000) {
      const randomLane = Phaser.Math.Between(0, 2);
      this.spawnObject('extrabonus', randomLane);
      this.lastDiamondSpawnTime = time;
    }

    if (time - this.lastObstacleSpawnTime > 800) {
      const lanes = Phaser.Utils.Array.Shuffle([0, 1, 2]);
      let placedObstacles = 0;

      for (let i = 0; i < lanes.length; i++) {
        const lane = lanes[i];
        if (placedObstacles < 2 && Phaser.Math.Between(0, 1000) < 300) {
          this.spawnObject('obstacle', lane);
          placedObstacles++;
        } else if (Phaser.Math.Between(0, 1000) < 80) { // Увеличено до 80 для лучшего баланса
          this.spawnObject('bonus', lane);
        }
      }
      this.lastObstacleSpawnTime = time;
    }

    this.obstacles.children.iterate(child => child.y += this.speed * delta / 1000);
    this.bonuses.children.iterate(child => child.y += this.speed * delta / 1000);
    this.extraBonuses.children.iterate(child => child.y += this.speed * delta / 1000);
    
    // Анимация дороги - движение элементов вниз для создания эффекта езды
    this.roadElements.children.iterate(roadElement => {
      roadElement.y += this.speed * delta / 1000 * 0.5; // Дорога движется медленнее объектов
      
      // Если элемент дороги ушел за нижний край экрана, перемещаем его наверх
      if (roadElement.y > this.sys.game.config.height * 1.5) {
        roadElement.y -= this.sys.game.config.height * 3;
      }
    });
  }

  spawnObject(type, lane) {
    const x = this.roadStart + lane * this.laneWidth + this.laneWidth / 2;
    const y = -60;
    
    if (type === 'extrabonus') {
      // Создаем монетку с анимацией кадров
      const coin = this.extraBonuses.create(x, y, 'coin1');
      coin.setDisplaySize(this.sys.game.config.width * 0.1, this.sys.game.config.height * 0.08);
      coin.setImmovable(true);
      
      // Анимация переключения между coin1 и coin2
      this.time.addEvent({
        delay: 500,
        callback: () => {
          if (coin && coin.active) {
            if (coin.texture.key === 'coin1') {
              coin.setTexture('coin2');
            } else {
              coin.setTexture('coin1');
            }
          }
        },
        repeat: -1
      });
      
      // Легкое мерцание
      this.tweens.add({
        targets: coin,
        alpha: 0.8,
        duration: 1000,
        yoyo: true,
        repeat: -1
      });
    } else if (type === 'bonus') {
      // Создаем бонус с анимацией кадров
      const sprite = this.bonuses.create(x, y, 'bonus1');
      sprite.setDisplaySize(this.sys.game.config.width * 0.12, this.sys.game.config.height * 0.08);
      sprite.setImmovable(true);
      
      // Анимация переключения между bonus1 и bonus2
      this.time.addEvent({
        delay: 400,
        callback: () => {
          if (sprite && sprite.active) {
            if (sprite.texture.key === 'bonus1') {
              sprite.setTexture('bonus2');
            } else {
              sprite.setTexture('bonus1');
            }
          }
        },
        repeat: -1
      });
    } else if (type === 'obstacle') {
      // Используем машинки препятствий в зависимости от локации
      let obstacleTextures;
      switch (this.currentLocation) {
        case 'locSand':
          obstacleTextures = ['sandCar4', 'sandCar5', 'sandCar6'];
          break;
        case 'locbridge':
          obstacleTextures = ['bridgeEc', 'bridgeEc1', 'bridgeEc2', 'bridgeCar4', 'bridgeCar5', 'bridgeCar6'];
          break;
        case 'loccity':
          obstacleTextures = ['cityEc', 'cityEc1', 'cityEc2'];
          break;
        default:
          obstacleTextures = ['sandCar4', 'sandCar5', 'sandCar6'];
      }
      
      const obstacleTexture = obstacleTextures[Phaser.Math.Between(0, obstacleTextures.length - 1)];
      const sprite = this.obstacles.create(x, y, obstacleTexture);
      sprite.setDisplaySize(this.sys.game.config.width * 0.14, this.sys.game.config.height * 0.09);
      sprite.setImmovable(true);
    }
  }
  
  changeLocation() {
    // Меняем локацию
    const newLocation = GameData.advanceLocation();
    this.currentLocation = newLocation;
    
    // Показываем уведомление о смене локации
    let locationName;
    switch (newLocation) {
      case 'locSand':
        locationName = 'ПУСТЫНЯ';
        break;
      case 'locbridge':
        locationName = 'МОСТ';
        break;
      case 'loccity':
        locationName = 'ГОРОД';
        break;
      default:
        locationName = 'НОВАЯ ЛОКАЦИЯ';
    }
    
    this.showLocationNotification(locationName);
    
    // Обновляем фон дороги
    this.updateRoadBackground();
  }
  
  updateRoadBackground() {
    // Определяем новое изображение для локации
    let roadImage;
    switch (this.currentLocation) {
      case 'locSand':
        roadImage = 'bgsand';
        break;
      case 'locbridge':
        roadImage = 'bridge';
        break;
      case 'loccity':
        roadImage = 'city';
        break;
      default:
        roadImage = 'bgsand';
    }
    
    // Обновляем все элементы дороги
    this.roadElements.children.iterate(roadElement => {
      roadElement.setTexture(roadImage);
    });
  }
  
  showLocationNotification(locationName) {
    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;
    
    // Создаем уведомление о смене локации
    const notification = this.add.text(gameWidth / 2, gameHeight / 2, `НОВАЯ ЛОКАЦИЯ:\n${locationName}`, {
      font: 'bold 32px Commissioner',
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 3,
      align: 'center'
    }).setOrigin(0.5);
    
    // Анимация появления и исчезновения
    this.tweens.add({
      targets: notification,
      scaleX: 1.2,
      scaleY: 1.2,
      duration: 500,
      yoyo: true,
      ease: 'Back.easeOut'
    });
    
    this.tweens.add({
      targets: notification,
      alpha: 0,
      duration: 3000,
      ease: 'Power2',
      onComplete: () => {
        notification.destroy();
      }
    });
  }

  changeLane(dir) {
    if (this.gameOverFlag) return;
    
    const newLane = Phaser.Math.Clamp(this.player.lane + dir, 0, this.laneCount - 1);
    if (newLane !== this.player.lane) {
      this.player.lane = newLane;
      
      // Меняем спрайт и анимируем тень в зависимости от направления поворота
      if (dir > 0) {
        this.player.setTexture('carR');
        this.player.currentDirection = 'right';
        this.tweens.add({
            targets: this.playerShadow,
            scaleX: 1.1,
            angle: 15,
            duration: 150,
            yoyo: true,
            ease: 'Sine.easeInOut'
        });
      } else {
        this.player.setTexture('carL');
        this.player.currentDirection = 'left';
        this.tweens.add({
            targets: this.playerShadow,
            scaleX: 1.1,
            angle: -15,
            duration: 150,
            yoyo: true,
            ease: 'Sine.easeInOut'
        });
      }
      
      // Возвращаем обычный спрайт через короткое время
      this.time.delayedCall(300, () => {
        if (this.player && !this.gameOverFlag) {
          this.player.setTexture('car');
          this.player.currentDirection = 'center';
        }
      });
      
      this.player.x = this.roadStart + this.player.lane * this.laneWidth + this.laneWidth / 2;
    }
  }

  handleGameOver() {
    if (this.gameOverFlag) return;
    this.gameOverFlag = true;

    // Воспроизводим звук столкновения
    SoundManager.playSound(this, 'smash', 0.7);
    
    // Останавливаем игровую музыку
    SoundManager.stopMusic(this);

    // Сохраняем счет
    GameData.saveScore(this.score);

    this.physics.pause();
    this.player.setTint(0xff0000);

    // Экран окончания игры
    const gameWidth = this.sys.game.config.width;
    const gameHeight = this.sys.game.config.height;
    
    // Затемнение фона
    const overlay = this.add.rectangle(gameWidth / 2, gameHeight / 2, gameWidth, gameHeight, 0x000000, 0.8);
    
    // Основное окно диалога
    const dialogBg = this.add.graphics();
    dialogBg.fillStyle(0x222222, 0.95);
    dialogBg.fillRoundedRect(gameWidth / 2 - 200, gameHeight / 2 - 150, 400, 300, 15);
    dialogBg.lineStyle(3, 0xFFEE00);
    dialogBg.strokeRoundedRect(gameWidth / 2 - 200, gameHeight / 2 - 150, 400, 300, 15);
    
    // Заголовок
    this.add.text(gameWidth / 2, gameHeight / 2 - 80, 'ИГРА ОКОНЧЕНА', { 
      font: 'bold 28px Commissioner', 
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5);
    
    // Счет с анимацией прокрутки
    this.finalScoreText = this.add.text(gameWidth / 2, gameHeight / 2 - 40, 'Итоговый счет: 0', { 
      font: 'bold 20px Commissioner', 
      fill: '#C8C8C8',
      stroke: '#222222',
      strokeThickness: 1
    }).setOrigin(0.5);
    
    // Анимация прокрутки счета от 0 до финального значения
    const finalScore = Math.floor(this.score);
    const scoreCounter = { value: 0 };
    
    this.tweens.add({
      targets: scoreCounter,
      value: finalScore,
      duration: 2000, // 2 секунды анимации
      ease: 'Power2',
      onUpdate: () => {
        this.finalScoreText.setText('Итоговый счет: ' + Math.floor(scoreCounter.value));
        // Добавляем эффект мерцания во время подсчета
        if (scoreCounter.value < finalScore) {
          this.finalScoreText.setFill('#FFEE00');
        } else {
          this.finalScoreText.setFill('#C8C8C8');
        }
      },
      onComplete: () => {
        // Финальный эффект при завершении подсчета
        this.tweens.add({
          targets: this.finalScoreText,
          scaleX: 1.2,
          scaleY: 1.2,
          duration: 200,
          yoyo: true,
          ease: 'Back.easeOut'
        });
      }
    });
    
    // Кнопка "Начать заново"
    this.createGameOverButton(gameWidth / 2, gameHeight / 2 + 10, 'НАЧАТЬ ЗАНОВО', () => {
      this.scene.restart();
    });

    // Кнопка "Меню"
    this.createGameOverButton(gameWidth / 2, gameHeight / 2 + 70, 'МЕНЮ', () => {
      this.scene.start('MenuScene');
    });
  }

  createGameOverButton(x, y, text, callback) {
    // Создаем фон кнопки со скруглениями в корпоративном стиле
    const buttonBg = this.add.graphics();
    buttonBg.fillStyle(0xFFEE00);
    buttonBg.fillRoundedRect(x - 120, y - 25, 240, 50, 15);
    buttonBg.lineStyle(3, 0x222222);
    buttonBg.strokeRoundedRect(x - 120, y - 25, 240, 50, 15);

    // Невидимая область для клика (больше основной кнопки)
    const clickArea = this.add.rectangle(x, y, 260, 70, 0x000000, 0);
    clickArea.setInteractive();

    const button = this.add.text(x, y, text, {
      font: 'bold 20px Commissioner',
      fill: '#222222'
    }).setOrigin(0.5);

    clickArea
      .on('pointerdown', callback)
      .on('pointerover', () => {
        buttonBg.clear();
        buttonBg.fillStyle(0x222222);
        buttonBg.fillRoundedRect(x - 120, y - 25, 240, 50, 15);
        buttonBg.lineStyle(3, 0xFFEE00);
        buttonBg.strokeRoundedRect(x - 120, y - 25, 240, 50, 15);
        button.setFill('#FFEE00');
        button.setScale(1.05);
      })
      .on('pointerout', () => {
        buttonBg.clear();
        buttonBg.fillStyle(0xFFEE00);
        buttonBg.fillRoundedRect(x - 120, y - 25, 240, 50, 15);
        buttonBg.lineStyle(3, 0x222222);
        buttonBg.strokeRoundedRect(x - 120, y - 25, 240, 50, 15);
        button.setFill('#222222');
        button.setScale(1);
      });
    return button;
  }

  handleSwipe(endX, endY) {
    const deltaX = endX - this.touchStartX;
    const deltaY = endY - this.touchStartY;
    
    const minSwipeDistance = 30;
    
    if (Math.abs(deltaX) > minSwipeDistance) {
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > 0) {
          this.changeLane(1);
        } else {
          this.changeLane(-1);
        }
      }
    } else {
      const screenWidth = this.sys.game.config.width;
      if (endX < screenWidth / 2) {
        this.changeLane(-1);
      } else {
        this.changeLane(1);
      }
    }
  }

  createSoundButton(x, y) {
    // Инициализируем состояние звука
    SoundManager.getMuteState();
    
    // Создаем кнопку звука
    const soundButton = this.add.text(x, y, SoundManager.isMuted ? '🔇' : '🔊', {
      font: 'bold 32px Arial',
      fill: '#FFEE00',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5).setInteractive();
    
    soundButton.on('pointerdown', () => {
      // Простое переключение звука без сложных overlay
      SoundManager.toggleMute();
      soundButton.setText(SoundManager.isMuted ? '🔇' : '🔊');
      SoundManager.updateMuteState(this);
      
      // Показываем уведомление
      this.showSoundNotification(x, y - 60);
    });
    
    soundButton.on('pointerover', () => {
      soundButton.setScale(1.05);
    });
    
    soundButton.on('pointerout', () => {
      soundButton.setScale(1);
    });
  }
  
  showSoundNotification(x, y) {
    // Создаем временное уведомление
    const notification = this.add.text(x, y, SoundManager.isMuted ? 'ЗВУК ВЫКЛЮЧЕН' : 'ЗВУК ВКЛЮЧЁН', {
      font: 'bold 16px Commissioner',
      fill: SoundManager.isMuted ? '#FF4444' : '#44FF44',
      stroke: '#222222',
      strokeThickness: 2
    }).setOrigin(0.5);
    
    // Анимация появления и исчезновения
    this.tweens.add({
      targets: notification,
      alpha: 0,
      y: y - 30,
      duration: 2000,
      ease: 'Power2',
      onComplete: () => {
        notification.destroy();
      }
    });
  }
}

const config = {
  type: Phaser.AUTO,
  width: 360,
  height: 780,
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    width: 360,
    height: 780
  },
  physics: { default: 'arcade' },
  scene: [MenuScene, ShopScene, PromotionsScene, LeaderboardScene, MainScene]
};

const game = new Phaser.Game(config);
</script>
</body>
</html>

